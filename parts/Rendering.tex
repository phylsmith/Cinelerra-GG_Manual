\chapter{Rendering}%
\label{cha:rendering}
\index{rendering}

To configure the render according to your needs and to obtain the desired output, you will need to check on what your settings are for these three items:

\begin{enumerate}
	\item \textbf{Timeline:} is the main starting point because, in addition to determining the range of frames that will be rendered, it is on the timeline that plugins and other editing features are applied, which will then be included in the rendered file. 
	\item \textbf{Set Format:} is used to configure the fps, aspect ratio and frame size of the project	(= output). This can be found in the pulldown: \texttt{Settings $\rightarrow$ Format... (Shift + F)}.
	See: \nameref{cha:project_and_media_attributes}.
	\item \textbf{Render dialog:} this is under: \texttt{File $\rightarrow$ Render... (Shift + R)}. It contains all the rendering options that are documented in this chapter.
\end{enumerate}

Rendering takes a section of the timeline, \index{active region} performs all the editing,
effects and compositing, and creates a new media file.  You can then
delete all the source assets, play the rendered file, or bring it
back into \CGG{} for more editing.  All rendering operations are
based on a region of the timeline to be rendered.  You need to
define this region on the timeline.  The rendering functions define
the region based on a set of rules.  When a region is highlighted or
in/out points are set, the affected region is rendered.  When no
region is highlighted, everything after the insertion point is
rendered.  By positioning the insertion point at the beginning of a
track and unsetting all in/out points, the entire track is rendered.
But you also have the choice to render \textit{one frame}. Reminder,
\CGG{} does not do remuxing without rendering - see \nameref{sec:transcode}.

\section{Single File Rendering}%
\label{sec:single_file_rendering}
\index{rendering!single file}

Use the \textit{File} pulldown and select Render to start the render dialog
(figure~\ref{fig:render}).  Then choose the desired parameters.

\begin{figure}[htpb] \centering
  \includegraphics[width=0.5\linewidth]{render.png}
  \caption{Example of the Render menu}
  \label{fig:render}
\end{figure}

\begin{description}
\item[Select a file to render to:] enter the path and filename to
  write the rendered file to in the textbox below.
\item[File Format:] \index{file format} use the down arrow to see file format options.
  For ffmpeg, which has its own set of options, you will then have to
  select an ffmpeg file type from the down arrow choices. The format
  of the file determines whether you can render audio or video or
  both.
\item[Render audio tracks:] check this toggle to generate audio
  tracks
\item[Render video tracks:] check this toggle to generate video
  tracks. The Render window will sometimes automatically update the
  Render Audio Tracks or Render Video Tracks checkbox as allowed by
  the chosen file format, but you should always check
  (figure~\ref{fig:render01}).  For example, if the PNG file format is
  selected, only the \textit{Render Video Tracks} will be checked.  Or
  if an ffmpeg format is chosen and the file format does not render
  audio, the \textit{Render Audio Tracks} will be unchecked. The
  invalid choices will be ghosted out.
\end{description}

\begin{figure}[htpb] \centering
  \includegraphics[width=0.7\linewidth]{render01.png}
  \caption{Audio and Video tracks automatically checked for Pro file
    type}
  \label{fig:render01}
\end{figure}

\begin{description}
\item[Wrench:] \index{wrench} select the \textit{wrench} next to each toggle to set
  compression parameters.  If the file format can not store audio or
  video the compression parameters will be blank.  If \textit{Render
    audio tracks} or \textit{Render video tracks} is selected and the
  file format does not support it, trying to render will result in an
  error message. There are several hardware related formats that will
  only work on specific computers that support that hardware/software
  implementation and will result in an error message if not available.
  Pick a different one.  This is especially relevant if using an AppImage
  which is generated on a computer with few extra hardware implemented
  features.
More details on differing parameters of the format in the section:
  \nameref{sub:extra_cin_option_ffmpeg}.
\item[Create new file at each label] the option causes a new file to
  be created when every label in the timeline is encountered – a
  separate file for each.  This is useful for dividing long audio
  recordings into individual tracks.  When using the Render Farm
  (described later), \textit{Create new file at each label} causes one
  render farm job to be created at every label instead of using the
  internal load balancing algorithm to space jobs.  If the filename
  given in the render dialog has a 2 digit number in it, the 2 digit
  number is overwritten with a different incremental number for every
  output file. If no 2 digit number is given, \CGG{} automatically
  concatenates a number to the end of the given filename for every
  output file.  For example, in the filename
  \texttt{/movies/track01.wav} the $01$ would be overwritten for every
  output file.  The filename \texttt{/movies/track.wav}; however,
  eventually would become \texttt{/movies/track.wav001} and so on.
  Filename regeneration is only used when either render farm mode is
  active or creating new files for every label is active.
\item[Render range:] \index{active region} choices are \textit{Project} \index{project},
  \textit{Selection}, \textit{In/Out points}, and \textit{One Frame}
  for single images like Tiff.  For these images, Render range will
  have \textit{One Frame} automatically checked and all of the others
  ghosted since nothing else makes sense (figure~\ref{fig:render02}).
  This makes it easy to set the insertion point where you want the 1
  frame to be rendered rather than having to precisely zoom in to set
  the in/out pointers.  Note that whichever Render range is checked,
  remains checked so that if \textit{One Frame} gets automatically
  checked, the next time you render it will still be checked and you
  will have to select a different one if desired.  That is why you
  should always check the settings.
\end{description}

\begin{figure}[htpb] \centering
  \includegraphics[width=0.7\linewidth]{render02.png}
  \caption{Render menu displaying a PNG \textit{one frame} option}
  \label{fig:render02}
\end{figure}

\begin{description}
\item[Beep on done:] as a convenience when a render is complete,
  check this box.  It gives you the chance to work on something else
  while waiting and still be immediately notified when the render is
  complete.
\item[Render Profile:] \index{rendering!profile} another convenience feature to take advantage
  of if you use specific render formats frequently, is to save that
  profile for future usage without having to set it up again.
\item[Save Profile:] after setting up your render preference
  formats, do not forget to type in a format name and then use the save profile
button to save it.  The named/saved Profiles will be saved in your
\$HOME/.bcast5/Cinelerra\_rc file where it can be carefully modified.
\item[Delete Profile:] if you want to delete a saved profile,
  highlight the one you no longer want and delete.
\item[Insertion strategy:] \index{insertion strategy} select an insertion mode from the
  available choices as seen when you click on the down arrow on the
  right hand side of the option. The insertion modes are the same as
  with loading files.  In the case if you select “insert nothing” the
  file will be written out to disk without changing the current
  project. For other insertion strategies be sure to prepare the
  timeline to have the output inserted at the right position before
  the rendering operation is finished.

  Even if you only have audio or only have video rendered, a paste
  insertion strategy will behave like a normal paste operation,
  erasing any selected region of the timeline and pasting just the
  data that was rendered.  If you render only audio and have some
  video tracks armed, the video tracks will get truncated while the
  audio output is pasted into the audio tracks.
\end{description}


\subsection{Extra “cin\_” Options for Render with FFmpeg}%
\label{sub:extra_cin_option_ffmpeg}
\index{rendering!ffmpeg options}

There are several special parameters that can be used in the ffmpeg
options file to pass values to the codecs that are not normally
available.  They're called Global Options. These are explained
below.

\paragraph{cin\_pix\_fmt} The Render menus allows you to choose the
codec input pixel format (figure~\ref{fig:yuv420}).  The Pixels
selection provides the available pixel format options for the chosen
codec type; valid choices vary for the different file types.  This
list represents the formats that the codec advertises.  It is not
always complete, and it may include options that are not legal with
all parameter configurations.

\begin{figure}[htpb] \centering
	\includegraphics[width=1.0\linewidth]{yuv420.png}
	\caption{Render \& Video Preset menus displaying Pixel choices}
	\label{fig:yuv420}
\end{figure}

\begin{itemize}
	\item The \textit{Bitrate}, \textit{Quality}, and \textit{Pixels}
	fields are only updated when the Video Options are reloaded.  This
	occurs when you either change the ffmpeg file format, or video
	presets compression fields.
	\item If the video options preset has \textit{cin\_pix\_fmt}
	defined, its value will be loaded as the default.  If you override
	the default, the value you specify will be used.
	\item If the video options preset does not have
	\textit{cin\_pix\_fmt}, the default pixel format will be computed by
	ffmpeg (\textit{avcodec\_find\_best\_pix\_fmt\_of\_list}), using the
	session format as the source choice.  The \textit{best} is usually
	the format which is most similar in color and depth.
	\item If no choices are available, yuv420p for video will be used.
	\item You can also specify ffmpeg pixel formats which are not in the
	list.  The list is provided by ffmpeg as input selection, but is
	more like suggestions than fact.  For example, the raw formats can
	take almost any format, but the rawvideo codec actually specifies no
	legal formats.  Note that if you want a very specific Bitrate you must
	make sure there is not conflicting parameter values set such as Quality
	or CRF.
\end{itemize}

\noindent Some option files provide \textit{cin\_pix\_fmt} to
suggest a choice for good quality output or to prevent parameter
errors when the other provided parameters conflict with the
\textit{best} pixel format.  This is the case in
\texttt{faststart\_h264.mp4} where the \textit{profile=high}
parameter dictates pixel format must be \texttt{yuv420p}.

\paragraph{cin\_bitrate} If you specify the bitrate, you can not
specify the quality or CRF.\\ Example: \textit{cin\_bitrate=2000000}

\paragraph{cin\_quality} If you specify the quality, you can not
specify the bitrate.\\ Example: \textit{cin\_quality=7}

\paragraph{cin\_stats\_filename} This parameter is useful for 2 pass
operations.\\ Example: \texttt{cin\_stats\_filename
	/tmp/cin\_video\_vp9\_webm}

\paragraph{cin\_sample\_fmt} For audio the preset sample format
default is computed in a similar way as stated above for video or
can be set with the \textit{cin\_sample\_fmt} parameter
(figure~\ref{fig:audio}).  If no choices are provided, s16 will be
used.\\ Example: \textit{cin\_sample\_fmt=s16}

\begin{figure}[htpb] \centering
	\includegraphics[width=0.7\linewidth]{audio.png}
	\caption{Render menu showing where Samples is}
	\label{fig:audio}
\end{figure}

\paragraph{Private Options} (muxers). In the window of the
\textit{wrench} in addition to the \textit{View} button, which
allows more global options and changes to the formats, there is an
additional \textit{Format} button that allows you to modify the
Private Options, i.e.\ relating to specific muxing formats. You can list private options available in a encoder with:

\begin{lstlisting}[style=sh]
	$ /path/to/cin/thirdparty/ffmpeg-X.Y/ffmpeg -h encoder='libcodec' (i.e. libx265)
\end{lstlisting}

More information on all these options can be found at
\href{https://ffmpeg.org/ffmpeg-all.html#Format-Options}{ffmpeg.org}
sections 19 and 21. See also \nameref{sub:modifying_ffmpeg_cinelerra}.

Render presets in \CGG{} should work Out Of the Box. You can still configure the \textit{Global Options} and \textit{Private Options} manually. Finding the combination of parameters that best suits your needs, or simply finding working (\textit{legal}) combinations, requires studying each codec in depth. You can start by looking in Wikipedia until you get to download and study the \textit{white papers} of the codecs of interest. In any case, you must then start a long experimental phase, trying presets with different configurations or creating new ones, until you get satisfactory results. If you create new presets it is a good idea to make them known on the mailing list ({\small \url{https://lists.cinelerra-gg.org/mailman/listinfo/cin}}) or on the MantisBT Bug Tracker ({\small \url{https://www.cinelerra-gg.org/bugtracker/my_view_page.php}}) so that they can be integrated into subsequent versions of \CGG{}. For an introduction see \nameref{sec:overview_formats}.

\section{Some Specific Rendering}%
\label{sec:some_specific_rendering}

\noindent The next few pages relate to rendering for specific common
cases. Also see: \small\url{https://gist.github.com/dexeonify/ed31c7d85fcf7297719e2ec4740fafda})

\subsection{FFmpeg Common H.264 Rendering}%
\label{sub:ffmpeg_h264_rendering}

Because H.264 is so widely used, the method in \CGG{} Infinity is
outlined below.  These setup steps make it easy to just get started.

\begin{itemize}
	\item File $\rightarrow$ Render
	\item File Format $\rightarrow$ FFMPEG + mp4
	\item Video Wrench $\rightarrow$ Preset $\rightarrow$ h264.mp4 +
	bitrate: 6000000 (or whatever) + OK
	\item Audio Wrench $\rightarrow$ Preset $\rightarrow$ h265.mp4 +
	bitrate: 224000 (or whatever) + OK
	\item Set your target path in: Render $\rightarrow$ Select a file to
	render to
	\item Set your timeline in: Render $\rightarrow$ Render range +
	click Project
	\item Set your insertion strategy: Replace project (or whatever)
	\item Press OK to start rendering.
\end{itemize}

\subsection{Lossless Rendering}%
\label{sub:loseeless_rendering}
\index{rendering!lossless}

Lossless means that in the compression of a file, all of the
original data, every single bit, can be recovered when the file is
uncompressed.  This is different than \textit{lossy compression}
where some data is permanently deleted so that when uncompressed,
all of the original data can not be exactly recovered.  Lossy is
generally used for video and sound, where a certain amount of
information loss will not be detected by most users or the playback
hardware does not reproduce it anyway -- it is a trade-off between
file size and image/sound quality.  The files created will be more
than 10 times larger than usual.  Most players will not be able to
decode lossless as the bitrate will overwhelm the device.

For x264 lossless compression to work, the only color model allowed
here is yuv420p.  Any other specification will be converted to
yuv420p and the data will be modified.  Also, keep in mind that the
YUV color model has to be converted to RGB, which also modifies the
data.

To use x264 lossless rendering -- choose File format of ffmpeg, m2ts
in the Render window.  Click on the Video wrench, which brings up
the Video Preset window and scroll down in the Compression filebox
and choose \texttt{lossless.m2ts}.  \textit{Preset=medium} is the
default, but can be varied from \textit{ultrafast} (least amount of
compression, but biggest file size) to \textit{veryslow} (most
amount of compression, but still HUGE) in the parameter box where
you see $qp=0$.  This option is also available for bluray creation.

\subsection{Two-pass Encoding with FFmpeg}%
\label{sub:two_pass_encoding_ffmpeg}
\index{rendering!ffmpeg two-pass encoding}

In \CGG{} for two-pass, you need to run ffmpeg twice, with the same
settings, except for designating the options of pass~1 for the first
pass and then pass~2.  In pass~1, a logfile that ffmpeg needs for
the second pass is created.  In pass~1 the audio codec should be
specified that will be used in pass~2.  For more information on
ffmpeg 2-pass, check
\href{https://trac.ffmpeg.org/wiki/Encode/H.264}{ffmpeg.org}.
Different libraries may have different requirements and you will
probably have to determine this by looking online at ffmpeg or
looking directly at that code.

This 2 line ffmpeg 2-pass operation can be functionally duplicated
in \CGG{} in the steps below them:

\begin{lstlisting}[style=sh]
	ffmpeg -y -i $INPUT \
	-c:v libx264 -b:v 2600k -pass 1 \
	-c:a aac -b:a 128k -f mp4 /dev/null && \
	ffmpeg -i $INPUT \
	-c:v libx264 -b:v 2600k -pass 2 \
	-c:a aac -b:a 128k $OUTPUT.mp4
\end{lstlisting}

\begin{enumerate}
	\item After you have completed your editing, do a Save Session with
	\texttt{File $\rightarrow$ Save as}\dots Before starting, be sure
	your session is ready for batch render. That is, positioned at the
	beginning and nothing selected.
	\item Bring up \texttt{File $\rightarrow$ Batch Render}\dots where
	you will do the setup.
	\item Click on the \textit{Delete} box to remove old jobs
	highlighted in the bottom listbox.
	\begin{itemize}
		\item For the \textit{File Format} choose ffmpeg and mp4 for the
		type.
		\item Set \textit{Output path} to the path and filename for the
		render output file.
		\item Click on \textit{Use Current EDL} to use the designated EDL
		Path file.
		\item Click on \textit{New} and you will see a new highlighted job
		show up in the listbox at the bottom.
		\item Use the Audio wrench to set bitrate to $128000$ ($128k$ as
		in ffmpeg example above).
		\item Click checkmark OK\@.  Open the video tools with the video
		wrench.
		\item Set the Video Compression to \textit{h264.mp4} (as seen in
		the example).
		\item Set the bitrate to $2600000$ ($2600k$ as in ffmpeg example
		above).
		\item Add the following 2 lines after the first line:
		\begin{lstlisting}[style=sh]
			flags +pass1
			passlogfile /tmp/"{temporary log file name}.log"
		\end{lstlisting} Click checkmark OK.
	\end{itemize}
	\item Click on \textit{New} to create the second pass job.  You will
	see this second job in the listbox below.  Use the Video wrench and
	change pass1 to pass2 as follows.
	\begin{lstlisting}[style=sh]
		flags +pass2
	\end{lstlisting}
	\item Click checkmark OK.
	\item Click on the \textit{Start} box and watch it go!
	\item You can now check the output file for results.  At the time
	this was documented, \textit{rc=2pass} will be in the output.
\end{enumerate}

If you need to re-render this, the Batch Render will still be set up
but you have to click on the \textit{Enabled} column in the listbox
to re-enable the jobs to run which puts an X there.  Click Start
again. You can reuse batch job using the \textit{save jobs} and
\textit{load jobs} buttons in the batch render dialog.

\paragraph{Render shortcuts for webm, h264, h265} are available by
using the option files that are already set up for this purpose.
Use the render menu as usual, with ffmpeg/mp4, choose h264 or h265
\textit{pass1of2\_h26x} for the video and
\textit{passes1and\-2\_h26x} for the audio; with ffmpeg/webm, choose
\textit{pass1of2\_vp9}.  When that is finished, you will have to use
the render menu again and this time for video, choose
\textit{pass2of2\_h26x} or \textit{pass2of2\_vp9}.  The logfile is
hard coded in the options file so will write over any currently
existing logfile if you do not change it before you start the
render.

\paragraph{Requirements for some other libraries} (used instead
of \textit{flags +pass1} \& \textit{passlogfile}):
\begin{description}
	\item[x265:] add this line:
	\begin{lstlisting}[style=sh]
		x265-params=pass=1:stats=/tmp/{temporary-log-file-name}.log
	\end{lstlisting} at the time this document was written, you should
	see in the output: \textit{stats-read=2}
	\item[libvpx-vp9, xvid, and huffyuv:]~
	\begin{lstlisting}[style=sh]
		cin_stats_filename /tmp/{temporary-log-file-name}.log
		flags +pass1 (or flags +pass2 for the second pass)
	\end{lstlisting}
\end{description}

\textit{NOTE:} for vp9, the best Pixels is \textit{gbrp}

\subsection{Use case: High Efficiency Video Coding (HEVC)}%
\label{sub:use_case_hevc}

An example of video profile based on CRF, a quality-controlled
variable bitrate, instead of fixed quality scale (ABR).  HEVC
(H.265) was developed as a successor to AVC (H.264) to more
efficiently compress the future large amounts of data from 2/4/8k
videos.  In comparison to AVC, an average saving of around 30
percent can be assumed for the same quality.  Because HEVC is not
bound to any size format, it is suitable for virtually any image
size.

The following example is HD and FullHD oriented and produces a
picture quality similar to the Blu-ray with some limitations.  As
container Matroska (\texttt{.mkv}) is used, but also mp4 and others
are possible.

\begin{lstlisting}[style=sh]
	matroska libx265
	
	# CRF 16 creates a balanced compromise
	# between quality and file size.
	crf=16
	
	# Preset changes encoding speed and generally
	# degrades the overall result. Medium (default)
	# always fits.
	preset=medium
	
	# Additional parameters that are passed on to the codec.
	# me=star improves the search for very fast
	# movements, but slows down the encoding.
	#x265-params=me=star
	
	# Keyint does FFmpeg automatically, otherwise
	# the setting must match the frame rate.
	#keyint_min=25
	
	# Profile does FFmpeg automatically.
	#profile=high
	
	# Source sRBG and retention of color space.
	# 720/1080=bt709 if no profile set. Useful
	# for formats smaller than 720 if no lossy
	# conversion is desired.
	colorspace=bt709
	color_trc=bt709
	color_primaries=bt709
	
	# Output in 10 bit, prevents 8-bit step formation
	pixel_format=yuv420p
\end{lstlisting}

\noindent \textit{NOTE:}

A CRF of 16 delivers satisfactory results in most cases. However, if
the video material is really \emph{grainy}, a CRF~16 can lead to
unwanted large files.  In this case, a trial export of perhaps one
minute should be performed. The resulting bit rate can be used to
correct the CRF to 17,\,18,\,19\ldots -- remember, a CRF of $0$ (zero)
means lossless, the higher the number the stronger the lossy
compression. The approximate calculation of the final file size can
be extrapolated from the sample export.

The color space information must be used explicitly so that it can
be included in the video. \CGG{} or FFmpeg does not write it by
itself. Without this information the players (e.\,g.\
\href{https://mpv.io/}{mpv}) stick to the dimensions of the video
and take the assumed color model from a table. With videos in the
dimensions from 720 to 1080 this is bt709. For smaller dimensions,
e.\,g.\ DVD, bt601 is assumed and for 4k and above it is
bt2020. Normally this is not a problem, but if you want to export a
FullHD without color loss to a smaller size like 576 for example,
you have to inform the encoder as well as the decoder of the
player. This also applies if the videos are to be loaded on video
platforms, where they are then converted into videos of different
sizes. It is a security measure to prevent false colors, such as the
color profiles in digital photos and the copies made from them.

The HEVC tuning has not been considered here, because it is is
rarely used and requires background knowledge.

Further links:
\begin{itemize}
	\item \href{http://x265.readthedocs.org/en/default/}{x265
		Documentation}
	\item \href{http://x265.readthedocs.org/en/latest/cli.html}{x265
		Command Line Options}
	\item \href{http://x265.readthedocs.org/en/latest/presets.html}{x265
		Presets/Tuning}
\end{itemize}


\subsection{YouTube with \CGG{}}%
\label{sub:youtube_with_cinelerra}
\index{rendering!youtube preset}

To create a youtube or dailymotion video, you can easily follow the steps below.  You will have to learn a lot more about \CGG{} to take full advantage of its capabilities and make some really special videos, but this is just to get a start and to see the possibilities.

\begin{enumerate}
	\item Start \CGG{}; usually you can do this by clicking on \CGG{} icon or key in \texttt{{cin\_path}/bin/cin}.
	\item In the Program window on the lower left side of your screen, left mouse click the \textit{File} pulldown.
	\item You will see \textit{Load files} as the second choice so left mouse click this and find your video file to
	load, highlight it, and check the green checkmark in the lower left hand corner to get it loaded.
	\item Edit your video in the Program window using the basic commands of:
	\begin{itemize}
		\item play and then stop using the space bar
		\item move the mouse and then left click to move the insertion (location) pointer
		\item cut a section out by holding down the left mouse and drag, then key in “x” to cut or “c” to copy
		\item paste a copy or cut section by moving the insertion pointer, then key in “v”
	\end{itemize}
	\item Add a title by highlighting the \textit{Video Effects} in the right hand side Resources window; then
	highlighting the \textit{Title} icon and dragging it to the Program window video track and dropping.
	\item Click on the middle icon button (looks like a magnifying glass) on the brown colored Title bar to
	bring up the Title window bottom text box and key in a title.
	\item Use the \textit{File} pulldown to select \textit{Render} to create the desired video.  In the \textit{Render} window just next to the empty box to the right of the \textit{ffmpeg} file format, click on the down arrow shown there
	to see the choices and pick \textit{youtube}.  Then move back up to key in the path and filename to render
	to.  It will pick all of the defaults automatically for you so then just click on the green checkmark to
	have it start.  There is a progress bar in the main window, very bottom of the right hand side.
	\item Key in “q” in the main window to get out of \CGG{} and yes or no to save your edit session.
\end{enumerate}

Youtube will allow the upload of the resulting rendered file as named.  However, Dailymotion requires that the file be named with an acceptable extension so you must rename the output file to have the extension of .webm instead of .youtube

There are currently 6 specific variations within the ffmpeg (file format) / youtube (file type) for different video options.  You see these when you click on the wrench to the right of the word Video and then the Compression down arrow in the Video Preset window.  The first 3 are based on Webm/Vp9\protect\footnote{credit by Frederic Roenitz} and contain basic comments of usage and where to find more information.

The first 3 below, plus any of the VP9 files under the file type of \textit{webm} are the recommended options to use because they are freely usable in any circumstance.

\begin{center}
	\begin{tabular}{lp{8cm}}
		\hline
		sd.youtube & Standard Definition use with default audio/Opus stereo.youtube \\
		hd.youtube & High Definition “ “ \\
		uhd.youtube & Ultra High Definition “ “ \\
		\hline
	\end{tabular}
\end{center}

For more details and options on VP9, see: {\small\url{https://developers.google.com/media/vp9}}

Alternatives based on h264 and for non-commercial use are listed below.  For Dailymotion, these must be renamed to have a different extension of .mp4 instead of .youtube before uploading.

\begin{center}
	\begin{tabular}{lp{8cm}}
		\hline
		sd\_h264.youtube & Standard Definition – must change to audio stereo\_with\_h264.youtube \\
		hd\_h264.youtube & High Definition -          “ “ \\
		uhd\_u264.youtube & Ultra High Definition - “ “ \\
		\hline
	\end{tabular}
\end{center}

These same steps have been verified to work for creating Dailymotion videos -- however, the created files must be renamed before uploading to change the youtube extension to webm instead for Dailymotion.

\subsection{VP9 parameters}%
\label{sub:vp9_parameters}
\index{rendering!VP9 parameters}

\textsc{VP9}\protect\footnote{credit Frederic Roenitz} is a video codec licensed under the BSD license and is
considered open source,
% Sisvel Announces AV1 Patent Pool, March 10, 2020
% https://www.streamingmedia.com/Articles/ReadArticle.aspx?ArticleID=139636
%  Webm / VP9 is a media file format which is free to use under the
%  BSD license and is open-source; thus there are no licensing
%  issues to be concerned about.
the \textsc{Webm} container is based on \textsc{Matroska} for video
and \textsc{Opus} for audio. There are some common \textsc{VP9} rendering
options files that support creation of video for YouTube,
Dailymotion, and other online video services. YouTube easy startup steps are documented above.

Note: For VP9 and AV1 presets, two pass rendering is recommended, which provides higher quality.

Below is one of the \textsc{VP9} rendering options file with documentation for specifics:

\textbf{webm libvpx-vp9}

from {\small \url{https://developers.google.com/media/vp9/settings/vod/}}

1280x720 (24, 25 or 30 frames per second)

Bitrate (bit rate)

\textsc{VP9} supports several different bitrate modes:

\textit{mode:}

\begin{tabular}{p{6cm}p{10cm}}
	\hline
	Constant Quantizer (Q) & Allows you to specify a fixed quantizer value; bitrate will vary \\
	Constrained Quality (CQ) & Allows you to set a maximum quality level. Quality may vary within bitrate parameters\\
	Variable Bitrate (VBR) & Balances quality and bitrate over time within constraints on bitrate\\
	Constant Bitrate (CBR) & Attempts to keep the bitrate fairly constant while quality varies\\
	\hline
\end{tabular}

CQ mode is recommended for file-based video (as opposed to streaming). The following FFMpeg command-line parameters are used for CQ mode:

\textit{FFMpeg}:

\begin{center}
	\begin{tabular}{p{4cm}p{10cm}}
		\hline
		-b:v <arg> & Sets target bitrate (e.g. 500k)\\
		-minrate <arg> & Sets minimum bitrate.\\
		-maxrate <arg> & Sets maximum bitrate.\\
		-crf <arg> & sets maximum quality level. Valid values are 0-63, lower numbers are higher quality.\\
		\hline
	\end{tabular}
\end{center}

\textit{Note 1}: Bitrate is specified in kbps, or kilobits per second. In video compression a kilobit is generally assumed to be 1000 bits (not 1024).

\textit{Note 2:} Other codecs in FFMpeg accept the \textit{-crf} parameter but may interpret the value differently. If you are using \textit{-crf} with other codecs you will likely use different values for VP9.

\texttt{bitrate=1024k}\\
\texttt{minrate=512k}\\
\texttt{maxrate=1485k}\\
\texttt{crf=32}

\textit{Tiling} splits the video into rectangular regions, which allows multi-threading for encoding and decoding. The number of tiles is always a power of two. 0=1 tile; 1=2; 2=4; 3=8; 4=16; 5=32\\
\texttt{tile-columns=2}

(modified from {\small \url{https://trac.ffmpeg.org/wiki/EncodingForStreamingSites}})

To use a 2 second \textit{GOP} (Group of Pictures), simply multiply your output frame rate $\times$ 2. For example, if your input is \textit{-framerate 30}, then use \textit{-g 60}.\\
\texttt{g=240}

number of \textit{threads} to use during encoding\\
\texttt{threads=8}

\textit{Quality} may be set to good, best, or realtime\\
\texttt{quality=good}

\textit{Speed}: this parameter has different meanings depending upon whether quality is set to good or realtime. Speed settings 0-4 apply for VoD in good and best, with 0 being the highest quality and 4 being the lowest. Realtime valid values are 5-8; lower numbers mean higher quality\\
\texttt{speed=4}

\subsection{Piping Video to a Command Line}%
\label{sub:piping_video_command_line}
\index{rendering!command line}

You can pipe a video to any command line on the computer, such as
ffmpeg.  This can be especially useful with raw video files.  Next
is an example usage.

\begin{enumerate}
	\item on a terminal window create a named pipe file, for example:
	\begin{lstlisting}[style=sh]
		mknod /tmp/piper.yuv p
	\end{lstlisting} load your video and do your editing
	\item set up your Render (\texttt{Shift-R}), you can choose a raw
	format such as \textit{yuv} or \textit{rgb}
	\item for the filename \textit{Select a file to render to}, use the
	named pipe as created in step 1 (\texttt{/tmp/piper.yuv})
	\item for \textit{Insertion Strategy}, you will want to make sure to
	select \textit{insert nothing}
	\item click for OK on the green checkmark.(the \CGG{} gui will look
	like it is hanging while waiting for a command line to use the
	pipe.)
	\item on the terminal window, keyin your command, for example:
	\begin{lstlisting}[style=sh]
		/mnt0/build5/cinelerra-5.1/thirdparty/ffmpeg-3.4.1/ffmpeg -f \
		rawvideo -pixel_format yuv420p -video_size 1280x720 \
		-framerate 30000/1001 -i /tmp/piper.yuv /tmp/pys.mov
	\end{lstlisting}
\end{enumerate}

A slightly different option can be used instead that may be more
familiar to some.  In the render menu after choosing the File Format
of \textit{ffmpeg}, use the pulldown to choose \textit{y4m} as the
file type.  This choice results in putting a header on the rendered
output with some pertinent information that can be used for ffmpeg
processing thus alleviating the requirement for
\textit{pixel\_format}, \textit{video\_size}, and \textit{framerate}
on the ffmpeg command line.  In this case the format is
\textit{yuv4mpegpipe} instead of \textit{rawvideo}.  An example
command line would look as follows (assuming the created pipe is
called \texttt{piper.y4m}):
\begin{lstlisting}[style=sh]
	ffmpeg -f yuv4mpegpipe -i /tmp/piper.y4m -vcodec libx264 /tmp/test.mp4
\end{lstlisting}

\subsection{Faststart Option for MOV type files}%
\label{sub:faststart_option_mov0}

If you have mov video and want to be able to start playing without
having to first load the entire video, \textit{-movflags=+faststart}
is needed for ffmpeg to put the meta-data, known as the \textit{moov
	atom}, at the beginning of the file.  Otherwise, ffmpeg puts this
atom at the end of the video file which means you have to wait to
play until the whole video is loaded.  Or worse yet, if the file
becomes damaged in the middle and you can not get to the end, you
won’t be able to play anything.

Now you can have the \textit{moov atom} put on the front of the file
(automatically via a second pass).  To do this, when rendering using
ffmpeg \& either the mp4 or qt format/container, click on the
video/audio wrenches and choose \textit{faststart\_h264}.  With the
\textit{qt} format, settings will just be the default whereas the
\textit{mp4} format uses the highest quality and lowest file size as
possible, but you can easily modify these options in the associated
Video Preset textbox.

\section{About Image Sequences}%
\label{sec:about_image_sequences}
\index{image sequence}

\CGG{} supports image sequences with both decoding and encoding.

\CGG{} by default uses ffmpeg as encoding/decoding engine but we can disable it to have the specific internal engine available. See \nameref{sec:ffmpeg_early_probe_explanation} on how to switch between engines. With the internal engine we can create and load sequences of OpenEXR; PNG; TIFF; TGA; GIF; PPM and JPEG. There is also support for DPX sequences, but only in read and without rendering presets. With ffmpeg we can create and load DPX sequences or create a custom preset for any kind of image. Using these formats results in great timeline efficiency and high video quality at the cost of taking up a lot of space because they are uncompressed (or with lossless compression).
By rendering, you will get as many still images as there are frames in the project, plus a \textit{file-list} (or \textit{TOC}) that indexes the images. A good practice is to create a folder to contain the images (for example \texttt{/tmp/img\_seq/}) and then open the rendering window in \CGG{} and set a serial and increasing number as the name (for example: \texttt{/tmp/img\_seq/image \%05d.png}). \textit{image} is a generic name chosen at will; $\%$ creates a progressive sequence of distinct images; $05d$ indicates how many digits the image number will be, in this case 5 digits to go from $00000$ to $99999$.
Once we have our folder of images, if we want to import it in a project just load the file-list, which includes the link to all the files of the sequence.
To learn more about using and creating a preset with ffmpeg of an image sequence, see \nameref{sec:ffmpeg_image2_streams} and/or \nameref{sec:image_sequence_creation}.

\section{Data storage formulas}%
\label{sec:data_storage_formulas}
\index{data storage}

If we are dealing with large projects and poorly compressed formats, we will get large files that are difficult to manage and take up a lot of space on the HDD. We present some simple formulas to be able to calculate the space that will be occupied and the data rates we have to deal with:

\begin{description}
	\item[Frame size] 
	
	\[ \dfrac{Width \times Height [pixels] \times BitDepth [bits/pixel] \times Color}{8 [bit/Byte]} \] 	
	\[= ... [MB/frame] \]
	\item[File size] 
	
	\[ Frame size [MB/frame] \times frames [frame] = ... [MB] \]
	\item[Data Rate] 
	
	\[ Frame size [MB/frame] \times fps [frame/sec] = ... [MB/sec] \]
	\item[Data in 1 Hour] 
	
	\[ \dfrac{Data Rate [MB/sec] \times 3600 [sec]}{1024MB/GB}  = ... [GB] \]	
\end{description}

\section{Batch Rendering}%
\label{sec:batch_rendering}
\index{batch rendering}

Batch Rendering as implemented in \CGG{} is considered to be more of
an advanced feature and careful usage is advised.  It automates the
rendering of audio/video files in that
you can establish a set of job parameters, save them, and use them
repeatedly (figure~\ref{fig:batch01}).  It also allows for \CGG{} to
be run by external programs, with no need for the user to manually
interact with the user interface.

\begin{figure}[htpb] \centering
	\includegraphics[width=1.0\linewidth]{batch01.png}
	\caption{Example of the Batch Render menu}
	\label{fig:batch01}
\end{figure}

If you want to render many projects \index{project} to media files without having to
constantly set up the render dialog for each one, batch rendering is
a more efficient method of rendering. To use this feature you need to 
understand certain concepts.

\begin{enumerate}
	\item  You must define a list of Batches (\textit{Job} \index{job}) before starting the rendering. This is created using the \textit{New} button and displayed in \textit{Batches to Render} dialog.
	\item Each batch consists of a source project already created in \CGG{}, e.g. \texttt{aaa.xml}, to which we assign the rendering parameters.
	\begin{itemize}
		\item to associate \texttt{aaa.xml} to the batch we use the \textit{EDL Path} input field.
		\item we decide a name and path for the output file.
		\item let's set the \textit{File Format} of the output file.
		\item We configure the file with the Audio/Video \textit{wrench}.
		\item we decide whether to create different files for each \textit{label} and whether to use a \textit{Render farm}.
	\end{itemize}
	\item Created the first batch, we will see it appear in the dialog \textit{Batches to Render}.
	\item Using the \textit{New} button again we create a second batch for another source project (\texttt{bbb.xml}) and configure it at will.
	\item We continue with the source projects \texttt{ccc.xml}, \texttt{ddd.xml}, etc. until we run out of projects that we want to render in batch.
	\item Note that each batch has its own name, path and rendering parameters.
	\item Now we have our \textit{Job}, a list of batches. We can still configure it or modify it if we want to change something. In addition we can delete a batch from the list or we can disable it in the \textit{Enabled} field so that it is not taken into account during rendering, but without deleting it.
	\item Finally we start batch rendering with the \textit{Start} button.
\end{enumerate}

Let's see in detail how to set the Batch Rendering.

The first thing to do when preparing to do batch rendering is to
create one or more \CGG{} projects to be rendered and save them as a
normal project, such as \texttt{aaa.xml}.  The batch renderer
requires a separate project file for every batch to be rendered.
You can use the same \CGG{} project file if you are rendering to
different output files, as in an example where you might be creating
the same output video in different file formats.

You do not have to render an entire projects. We can limit ourselves to an \textit{active region} \index{active region} that we can set through a selection in Cut and Paste mode, with labels or In/Out Points. Or the rendering will start from the Insert Point position until the end of the project. Remember: if we want to render the entire project (and not just one active region) it is important to bring the Insertion Point to the beginning of the timeline. This is the only way we are sure to include the whole project.

With all the \CGG{} xml project files prepared with active regions,
go to \texttt{File $\rightarrow$ Batch Render}. This brings up the
batch render dialog. The interface for batch rendering is more
complex than for single file rendering.  A list of batches must be
defined before starting a batch rendering operation.  The table of
batches appears on the bottom of the batch render dialog and is
called \textit{Batches to render}.  Above this are the configuration
parameters for a single batch; a batch is simply a pairing of a
project file with a choice of output file and render settings.

It may be advisable to start with a \textit{Delete} so you don't have any problems. Set the \textit{Output path}, \textit{File format}, \textit{Audio},
\textit{Video}, and \textit{Create new file at each label}
parameters as if you were rendering a single file.  These parameters
apply to only one batch.  In addition to the standard rendering
parameters, you must select the \textit{EDL Path} to be the project
file (such as \texttt{aaa.xml}) that will be used in the batch
job.  In this case, \textit{EDL Path} is not related in anyway with
the EDL files as created by \texttt{File/Export EDL}.  In batch
render mode the program will not overwrite an existing output file
and will simply fail, so make sure that no files with the same name
as the output files exist before starting.

If the batches to render list is empty or nothing is highlighted,
click \textit{New} to create a new batch. The new batch will contain
all the parameters you just set.  Repeatedly press the \textit{New}
button to create more batches with the same parameters.  When you
highlight any batch, you can edit the configuration on the top of
the batch render window. The highlighted batch is always
synchronized to the information displayed.  You can easily change
the order in which the batch jobs are rendered, by clicking and
dragging a batch to a different position.  Hit \textit{Delete} to
permanently remove a highlighted batch. In the list box is a column
which enables or disables the batch with an \texttt{X} meaning the
batch job is enabled and will be run.  This way batches can be
skipped without being deleted.  Click on the \textit{Enabled} column
in the list box to enable or disable a batch.

The description of each of the columns in the batch list are as
follows:

\begin{description}
\item[Enabled:] an X in this column means the batch job will be run.
\item[Labeled:] an \texttt{X} in this column goes hand in hand with
  create new file at each label.
\item[Farmed:] to use or not the render farm.
\item[Output:] path and filename for the generated output.
\item[EDL:] the path and filename of the source EDL for the batch
  job.
\item[Elapsed:] the amount of time taken to render the batch if
  finished.  If field is empty, it did not run.
\end{description} 

The \texttt{File $\rightarrow$ Batch Render} pulldown brings up the
Batch Render window to be used for batch rendering as well as DVD/BD
creation.  There are some additional buttons that can save time and
mistakes.  These are described next.

\begin{description}
	\item[Save Jobs] when you have set up the batch jobs the way you
	want and you think you may have to run them more than once, it is
	beneficial to save the jobs for later use so you easily run them
	again.  It is recommended to use a filename with .rc as the extension
	so that it is obvious that it is a list of batch jobs to be run.
	\item[Load Jobs] reload a previous set of saved jobs.  This can come
	in handy if you did not have the time to render them when you
	originally set them up, if you need to rerun, or if you got
	interrupted.
\end{description}

To start rendering from the first enabled batch,
hit \textit{Start}.  Once rendering, the main window shows the
progress of the batch. After each batch finishes, the elapsed column
in the batch list is updated and the next batch is rendered until
all the enabled batches are finished.  The currently rendering batch
is always highlighted red.  To stop rendering before the batches are
finished without closing the batch render dialog, hit \textit{Stop}.
To stop rendering before the batches are finished and close the
batch render dialog, hit \textit{Close}.  Or you can exit the batch
render dialog whether or not anything is being rendered, by hitting
\textit{Close}.

You can automate \CGG{} batch renders from other programs.  In the
batch render dialog, once you have created your list of batch render
jobs, you can click the button \textit{Save Jobs} and choose a file
to save your batch render list to.  It is recommended that you use
a filename with the extension of .rc in order to make it obvious that
this is a list of batch jobs to render. Once you have created this file,
you can start up a batch render without needing to interact with the
\CGG{} user interface.  From a shell prompt, from a script, or other
program, execute:

\begin{lstlisting}[style=sh]
{path_to_cinelerra}/cin -r batchjob.rc
\end{lstlisting} substituting your actual filename for
\texttt{batchjob.rc}. \textbf{Warning} this file will be modified
so if you use any filename that is not a legitimate list of batch jobs to
render, that file will be overwritten and its previous contents destroyed.
When invoked with these parameters, \CGG{} will start up and run the
rendering jobs in the list contained in that file starting at the defined
\textit{active region}, without creating its usual windows. If you do not
specify a filename, the default will be \$HOME/.bcast5/batchrender.rc.
Possible messages you might see where you started up the job are as follows.
\begin{description}
\item[The following files exist: - filename - Won't overwrite existing files] that batch job will not run in order to prevent writing over previous run.
\item["filename" No such file or directory] the specified batch job file does not exist.
\item["filename": Permission denied] the specified batch job file does not have write permission so can not be updated.
\item[Render::run: filename] the batch job with the name of filename will be processed.
\item[** rendered 0 frames in 0.000 secs, 0.000 fps] either you used a file that is not a list of batch jobs or the batch jobs within the file were not enabled.
\end{description}

\subsection{Advanced features}%
\label{sub:advanced_features}
\index{batch rendering!more options}

\textbf{Warning}: \textit{Save to EDL path} overwrites the current EDL thus destroying the original contents.

Although the operation of Batch Rendering in \CGG{} is similar to that of other NLEs, there is one big difference that we need to take into account. The render setup is not done on a project-by-project basis, which are then brought into the Batch window to be rendered automatically. The setup must be done in the Batch rendering window, where various projects are loaded and set up. In the case of similar projects, derived from a single EDL with some variation, this mode offers the possibility of altering the projects without having to open each individual project, make the changes, set up the rendering, save and import into the Batch window. The procedure is to select the batch we want to modify in the Batches to render window; operate on the currently open timeline (even if it does not correspond to the one we want to modify) making the desired changes and then press the \textit{Save to EDL path} button. Thus the chosen batch, while retaining its original name, will now contain the modified project. Since this possibility destroys the original EDL overwriting it with the modified one, you must be very careful. This procedure is convenient in case the batches are similar, i.e. they are variations of the same EDL, where we want to experiment with other effects, other output formats or when trying out various cuts of a DVD/BD before the final production. It might also be useful to use an \textit{active region} of the timeline, so as to speed up rendering times but still have an indicative result for comparison. Instead operating on different projects, we can do a \textit{save as...} of the project on the timeline to have a new EDL with a new name and then replace it with the batch selected in the joblist using the \textit{Use Current EDL} button. The new project (with its name) overwrites the original project.

The \textit{Save to EDL Path} and \textit{Use Current EDL} buttons
can be valuable tools for advanced usage or for developers doing
testing.  Description of how you can expect them to work will help
to illustrate how to take advantage of their capabilities (figure~\ref{fig:batch-advanced}):

\begin{figure}[htpb] \centering
	\includegraphics[width=0.7\linewidth]{batch-advanced.png}
	\caption{New Buttons with Unsafe GUI in batchrender}
	\label{fig:batch-advanced}
\end{figure}


\begin{description}
\item[Save to EDL Path] Warning: this function overwrites the contents of the original EDL with new data, keeping the name of the original. If we don't know exactly what we're doing we may lose the original project. If you have made a change to the EDL, use
  this button to save the changes so that they will be used in the
  render operation.  Although you can get the same results by using
  \texttt{File $\rightarrow$ Save\dots}, this capability was initially
  added to assist developers in testing the batch jobs needed to
  create dvd/bluray media as it keeps the work focused in a single
  window and retains the original job name.  An example --you have
  everything all set up with a new job in the Batch Render window
  using \texttt{generic.xml} for the EDL path and with a job name of
  \texttt{original\_name.xml}.  Then you realize that you forgot to
  cut out a section in the media that is not wanted in the final
  product.  You can cut that out and then \textit{Save to EDL Path} so
  your change will be in effect for the rendering.  Without this
  button, you would be using the EDL you started with and the cut
  would be ignored.  Alternatively, if the cut changes are saved via
  \texttt{File $\rightarrow$ Save as}\dots with a filename of
  \texttt{new.xml} and then you use \textit{Save to EDL Path}, the
  current highlighted job displayed in the window as
  \texttt{original\_name.xml} will be replaced with \texttt{new.xml}.
  However, it is important to note that the result will be saved with
  the name \texttt{original\_name} – that is, the new content from
  \texttt{new.xml} but with the old name of
  \texttt{original\_name.xml}. To have this functionality we have to enable the checkbox in \texttt{Settings $\rightarrow$ Preferences $\rightarrow$ Appearance} tab; section \textit{Dangerous:} and unchecked (default) \textit{Unsafe GUI in batchrender}.
\item[Use Current EDL] Warning: this function overwrites the contents of the original EDL with new project. If we don't know exactly what we're doing we may lose the original project. if you are working on media and still testing
  out the results, you can take advantage of this click-box to quickly
  get results.  Basically, you change the media, save that change with
  another name (in order to preserve the original name in case you
  don't like the changes), and press \textit{Use Current EDL}.  As an
  example, a user creates a new job in the Batch Render window using
  the current media, previously defined in generic.xml, with the EDL
  path of \texttt{generic.xml}.  The user then changes the media on
  the timeline, saves the changes via \texttt{File $\rightarrow$ Save
    as\dots} with a new name, such as \texttt{new\_name.xml}, and then
  clicks on \textit{Use Current EDL}.  In this case, the EDL path
  listbox will be automatically updated to the \texttt{new\_name.xml}
  and the current existing highlighted job will be replaced with the
  \texttt{new\_name.xml} in the EDL column.
\item[Warn if Jobs/Session mismatched] Warning: It is better to keep this function unchecked because it is only needed in case of changes on the original EDL. By default it is hidden and is shown only if we enable the checkbox in \texttt{Settings $\rightarrow$ Preferences $\rightarrow$ Appearance} tab; section \textit{Dangerous:} and checked \textit{Unsafe GUI in batchrender}. After you set up your render
  and press Start, the program checks to see if the current EDL
  session matches your Batch Render job.  If the EDL has been changed
  since the batch job was created, it warns you so that you have the
  opportunity to \textit{Save to EDL} path to record those changes.
  Otherwise, you can dismiss that warning box, disable the warning
  message by unchecking the box and use the original values.  If you
  never want to be warned about the mismatches, leave the box
  unchecked (figure~\ref{fig:batch02}). It is advisable to keep it unchecked because it can cause problems.
\end{description}

\begin{figure}[htpb] \centering
	\includegraphics[width=0.9\linewidth]{batch02.png}
	\caption{Batch render with the 4 ghosted buttons on the right side
		+ the Warning message below}
	\label{fig:batch02}
\end{figure}

A very clear tutorial on these features can be found \href{https://linuxvideoediting.blogspot.com/2021/01/save-edl-path-use-current-edl-in-cinelerra-gg.html}{here}\protect\footnote{credit Igor Vladimirsky}; in Russian but easily translatable with DeepL or similar.

\subsection{Command Line Rendering}%
\label{sub:command_line_rendering}
\index{rendering!command line}

The command line rendering method consists of a way to load the
current set of batch rendering jobs and process them without a
GUI\@. This is useful if you want to do rendering on the other side
of a low bandwidth network and you have access to a high powered
computer located elsewhere. Setting up all the parameters for this
operation is somewhat difficult. That is why the command line aborts
if any output files already exist.

To perform rendering from the command line, first run \CGG{} in
graphical mode. Go to \texttt{File $\rightarrow$ Batch Render}.
Create the batches you intend to render in the batch window and
close the window.  This automatically saves the batches in a file 
with the name of \$HOME/.bcast5/batchrender.rc. Set up the
desired render farm attributes in \texttt{Settings $\rightarrow$
  Preferences} and quit out of \CGG{} if you want to use the Render
Farm capability.  These settings are used the next time command line
rendering is used to process the current set of batch jobs without a
GUI\@.  It is important to remember that the rendering will begin at
the defined \textit{active region} saved when the project was saved. 

On the command line run:

\begin{lstlisting}[style=sh]
cin -r
\end{lstlisting}

\section{Background Rendering}%
\label{sec:background_rendering}
\index{background rendering}

Background rendering causes temporary output to be rendered
constantly while the timeline is being modified. The temporary
output is displayed during playback whenever possible. This is
useful for transitions and previewing effects that are too slow to
display in real time. If a Render Farm \index{render farm} is enabled, the render farm
is used for background rendering. This gives you the potential for
real-time effects if enough network bandwidth and CPU nodes exist.

Background rendering is enabled in the \texttt{Performance} tab of
the \texttt{Preferences} window. It has one interactive function
\texttt{Settings $\rightarrow$ Toggle background rendering} \index{background rendering!toggle}. This
sets the point where background rendering starts up to the position
of the insertion point. If any video exists, a red bar appears in
the time ruler showing what has been background rendered
(figure~\ref{fig:back-ren02}).  Because this creates a very large number 
of files, a Shell Command script is available to delete them if in the
default location.

\begin{figure}[htpb] \centering
  \includegraphics[width=1.0\linewidth]{back-ren02.png}
  \caption{Settings Background Rendering}
  \label{fig:back-ren02}
\end{figure}

It is often useful to insert an effect or a transition and then
select \texttt{Settings $\rightarrow$ Toggle background rendering}
right before the effect to preview it in real time and full frame
rates (figure~\ref{fig:back-ren}).

\begin{figure}[htpb] \centering
  \includegraphics[width=1.0\linewidth]{back-ren.png}
  \caption{Timeline with the top red bar}
  \label{fig:back-ren}
\end{figure}

\begin{description}
\item[Frames per background rendering job] This only works if a
  Render Farm is being used; otherwise, background rendering creates a
  single job for the entire timeline. The number of frames specified
  here is scaled to the relative CPU speed of rendering nodes and used
  in a single render farm job. The optimum number is 10 - 30 since
  network bandwidth is used to initialize each job.
\item[Frames to preroll background] This is the number of frames to
  render ahead of each background rendering job. Background rendering
  is degraded when preroll is used since the jobs are small. When
  using background rendering, this number is ideally 0. Some effects
  may require 3 frames of preroll.
\item[Output for background rendering] Background rendering
  generates a sequence of image files in a certain directory. This
  parameter determines the filename prefix of the image files. It
  should be accessible to every node in the render farm by the same
  path. Since hundreds of thousands of image files are usually
  created, ls commands will not work in the background rendering
  directory. The browse button for this option normally will not work
  either, but the configuration button for this option works. The
  default value will be /tmp/brender .  Because using background
  rendering creates a voluminous number of brender numbered files,
  a Shell Command script is available to delete them if they are
  in the default /tmp/brender format.
\item[File format] The file format for background rendering has to
  be a sequence of images. The format of the image sequences
  determines the quality and speed of playback. JPEG generally works
  well and is the default.
\end{description}
Tip: If you have rendered your whole project with \textit{File format}
set to JPEG and there are no missing numbers in the sequence, you can
create a video from that sequence outside of \CGG{}.
For example, if using the default output so that your files are named
/tmp/brender000000, /tmp/brender000001, ... in a window, you would type:

\begin{lstlisting}[style=sh]
ffmpeg -f image2 -i /tmp/brender0%5d -c:v copy brender.mov
\end{lstlisting}
which would create the video file brender.mov -  be sure to delete
existing brender files before creating a new sequence to ensure there
are no missing numerical values in the sequence.

\section{Render Farm Usage}%
\label{sec:render_farm_usage}
\index{render farm}

Render Farm uses background rendering, a feature of \CGG{} where the
video is rendered in the background, to speed up rendering
significantly.  Because rendering is memory and cpu intensive, using
multiple computers on a network via a render farm is a significant
gain. With \CGG{} installed on all nodes, the master node and the clients communicate via a network port that you specify.
The Master node is the one of the instance of \CGG{} that we normally start with its gui; the other nodes are the instances of \CGG{} that we decide to start in parallel from the terminal to create the Render farm (clients).
\CGG{} can distribute the rendering tasks over the network to the
other computers of the Render Farm; or among all threads of a multicore CPU.  The render farm software tries
to process all of the rendering in parallel so that several
computers can be used to render the results.  The \textit{Total jobs
to create} in the setup or labels on the timeline are used to divide
a render job into that specified number of tasks.  Each background
job is assigned a timeline segment to process and the jobs are sent
to the various computer nodes depending upon the load balance.  The
jobs are processed by the nodes separately and written to individual
files.  You will have to put the files back together via a load with
concatenation, or typically by using a command line tool from a
script.

\subsection{Basic Steps to Start a Render Farm}%
\label{sub:basic_steps_start_render_farm}

The following steps are just a guideline to start your render farm.
It is assumed that you already have the master and client nodes
communication, shared filesystem, permissions and usernames synched.
Let's take the example of a network with 2 PCs: the master and the client. On the client we set 5 tasks; on the master we set 2 tasks.

\begin{enumerate}
\item On the master computer, use \texttt{Settings} $\rightarrow$
  \texttt{Preferences} $\rightarrow$ \texttt{Performance} \texttt{tab}
  to set up a Render Farm:
  \begin{itemize}
  \item check the \textit{Use render farm} box;
  \item in the \textit{Hostname} box, keyin your hostname or ip
    address such as 192.168.1.12 or \textit{localhost} when using a single computer with a multicore CPU;
  \item enter in a port number such as 401--405 (only a root user
    can use privileged ports) or $10650...$ for non-root and click on \textit{Add Nodes}. To find a range of free ports to use you can look at the file \texttt{/etc/services};
  \item you will see something like the following in the Nodes
    listbox to the right:\newline
    \begin{tabular}{lllc}
    	\hline
    	On & Hostname & Port & Framerate\\
        \hline
        X & 192.168.1.12 & 10650 & 0.0 \\
        X & 192.168.1.12 & 10651 & 0.0 \\
        X & 192.168.1.12 & 10652 & 0.0 \\
        X & 192.168.1.12 & 10653 & 0.0 \\
        X & 192.168.1.12 & 10654 & 0.0 \\
        X & localhost & 10655 & 0.0 \\
        X & localhost & 10656 & 0.0 \\
        \hline
    \end{tabular}
  \item set the Total number of jobs to create. This number only pertains to client nodes, so we do not need to consider the master node;
  \item click OK on the bottom of the Preferences window.
  \end{itemize}
\item For external network nodes, now we must join the nodes created to instances of \CGG{}. On the client computers ($192.168.1.12$), on the terminal, start 5 background  \CGG{} tasks via:
\begin{lstlisting}[style=sh]
cd {path_to_cinelerra}
cin -d 10650 
cin -d 10651
...
cin -d 10654
\end{lstlisting}
In practice, at each instance that we start, the cursor will be positioned in a new line ready to enter the next command, without exiting the task. If we have several PCs on the network, repeat these steps for each new client (with its own ip address).
\item Similarly, on the terminal, we must join the local nodes (internal to the Master node) created to instances of \CGG{}. On the Master node (localhost), start the 2 background \CGG{}  tasks via:
\begin{lstlisting}[style=sh]
cd {path_to_cinelerra}
cin -d 10655
cin -d 10656
\end{lstlisting}
Similar to the previous point, the cursor positions itself in a new line ready to enter the next command, without exiting the task.
\item When your video is ready, setup a render job via \texttt{File
    $\rightarrow$ Render} or \texttt{File $\rightarrow$ Batch Render}
  and check OK.
\item The results will be in the shared file \texttt{path/filename}
  that you selected in the render menu with the additional numbered
  job section on the end as $001, 002, 003, \dots 099$ (example,
  \texttt{video.webm001}).
\item When finished, load your new files on new tracks via
  \texttt{File $\rightarrow$ Load} \textit{concatenate to existing
    tracks} or if you used ffmpeg, run \textit{RenderMux} from the Shell
  Scripts icon.
\item If you plan on doing more rendering, you can just leave the
  master/client jobs running to use again and avoid having to restart
  them. You can also close the terminal, but the jobs will remain active until you turn off the PC. Or you can kill them when you no longer are using them.
\end{enumerate}

\subsection{Render Farm Menu and Parameter Description}%
\label{sub:render_farm_parameter_description}
\index{render farm!parameters}

Below we describe the Performance tab for configuring a render farm
(figure~\ref{fig:farm}).

\begin{figure}[htpb] \centering
  \includegraphics[width=1.0\linewidth]{farm.png}
  \caption{Settings: Preferences: Performance tab, menu
    to set up your Render Farm}
  \label{fig:farm}
\end{figure}

\begin{description}
\item[Project SMP cpus] although this field is not Render Farm
  specific, it is useful for \CGG{} to have the CPU count and for
  using multiple threads.
\item[Use render farm] check this to turn on the render farm option.
  Once checked ALL rendering will be done via the farm including the
  usual Render (\texttt{Shift-R}).  You may want to turn if off for
  small jobs.
\item[Nodes listbox] displays all the nodes on the render farm and
  shows which ones are currently enabled. The Nodes listbox has 4
  columns -- On, Hostname, Port, Framerate -- which show the current
  values.  An \textit{X} in the \textit{On} designates that that host
  is currently enabled; \textit{Hostname} shows the name of the host;
  \textit{Port} shows the port number that host uses; and
  \textit{Framerate} will either be zero initially or the current
  framerate value.
\item[Hostname] this field is used to edit the hostname of an
  existing node or enter a new node.
\item[Port] keyin the port number of an existing or new node here.
  You can also type in a range of port numbers using a hyphen, for
  example $10650-10799$ when you need to add many.
\item[Apply Changes] this will allow you to edit an existing node
  and to then commit the changes to hostname and port. The changes
  will not be committed if you do not click the OK button.
\item[Add Nodes] Create a new node with the hostname and port
  settings.
\item[Sort nodes] sorts the nodes list based on the hostname.
\item[Delete Nodes] deletes whatever node is highlighted in the
  nodes list.  You can highlight several at once to have them all
  deleted.
\item[Client Watchdog Timeout] a default value of $15$ seconds is
  used here and the tumbler increments by $15$ seconds.  A value of
  $0$ (zero) disables the watchdog so that if you have a slow client,
  it will not kill the render job while waiting for that client to
  respond.
\item[Total jobs to create] determines the number of jobs to
  dispatch to the render farm.  Total jobs is used to divide a render
  job into that specified number of tasks.  Each background job is
  assigned a timeline segment to process.  The render farm software
  tries to process all of the rendering in parallel so that several
  computers can be used to render the results.  You should adjust
  this for each different video if your work varies considerably in
  time so that each task time is not too small.

  To start, if you have computers of similar speed, a good number
  for \textit{Total jobs to create} is the number of computers
  multiplied by $3$.  You will want to adjust this according to the
  capabilities of your computers and after viewing the framerates.
  Multiply them by $1$ to have one job dispatched for every node.  If
  you have $10$ client nodes and one master node, specify $33$ to have
  a well balanced render farm.
\item[(overridden if new file at each label is checked)] instead of
  the number of jobs being set to \textit{Total jobs to create}, there
  will be a job created for each labeled section.  If in the render
  menu, the option \textit{Create new file at each label} is selected
  when no labels exist, only one job will be created.  It may be quite
  advantageous to set labels at certain points in the video to ensure
  that a key portion of the video will not be split into two different
  jobs.
\item[Reset rates] sets the framerate for all the nodes to $0$.
  Frame rates are used to scale job sizes based on CPU speed of the
  node.  Frame rates are calculated only when render farm is enabled.
\end{description}

Framerates can really affect how the Render Farm works.  The first
time you use the render farm all of the rates are displayed as $0$
in the \texttt{Settings $\rightarrow$ Preferences}, Performance tab
in the Nodes box.  As rendering occurs, all of the nodes send back
framerate values to the master node and the preferences page is
updated with these values.  A rate accumulates based on speed.  Once
all nodes have a rate of non-zero, the program gives out less work
to lower rated nodes in an effort to make the total time for the
render to be almost constant.  Initially, when the framerate scaling
values are zero, the program just uses package length -- render size
divided by the number of packages to portion out the work (if not
labels).  If something goes wrong or the rates become suspect, then
all of the rest of the work will be dumped into the last job.  When
this happens, you really should \textit{reset rates} for the next
render farm session to restart with a good balance.

\begin{lstlisting}[style=sh]
{path_to_cinelerra}/cin -h  # displays some of the options.
\end{lstlisting}

\subsection{Multi-core CPU Setup (Localhost)}%
\label{sub:multi_core_render_farm_setup}
\index{render farm!multi core CPU}

If you are lucky enough to have a computer with a large cpu core
count, setting up a render farm can really take advantage of using
all of the cores at 100\%. This is much faster than the default automatic
threading capability. Since you don’t need to communicate with other
computers, you will not have to be concerned about TCP communication
or shared disks/files; only localhost nodes. On the terminal you will need to open many instances of \CGG{} by connecting them to the jobs created. The number of such jobs can be the total number of CPU threads (-1) or not. When you are going to be doing other work
simultaneously while rendering a large job, you will want to leave
some of the cpus available for that.  Be sure to set \textit{Project SMP cpus} in the \texttt{Settings $\rightarrow$ Preferences, Performance} tab to your CPU
count.  Follow the steps outlined in ~\ref{sub:basic_steps_start_render_farm}
but skip the step "For external network nodes".

\subsection{Detailed Setup Description}%
\label{sub:detailed_setup_description}
\index{render farm!setup}

{\color{red} CAUTION }, any exact command lines worked as of
$01/2018$ on a Fedora system.  These can change over time and on
different operating systems/levels.  Always check/verify any command
line before using.

\begin{description}
\item[Set up \CGG{}] A \CGG{} render farm is organized into a master
  node and any number of client nodes.  The master node is the
  computer which is running the gui.  The client nodes are anywhere
  else on the network with \CGG{} installed and are run from the
  command line.  Before you start the master node for \CGG{}, you need
  to set up a shared filesystem on the disk storage node as this is
  the node that will have the common volume where all the data will be
  stored.  The location of the project and its files should be the
  same in the client computers as in the master computer and to avoid
  problems of permissions, it is better to use the same user in master
  and clients.  For example, if you have the project in
  \texttt{/home/<user>/project-video} you must create the same
  directory path on the clients, but empty.  Sharing the directory of
  the location of your project on the master computer can be done with
  NFS as described next.  Alternatively, you can look up on the
  internet how to use Samba to share a directory.
\item[Create a shared filesystem and mount using NFS] (only for Network) All nodes in
  the render farm should use the same filesystem with the same paths
  to the project files on all of the master and client nodes.  This is
  easiest to do by setting up an NFS shared disk system.
  \begin{enumerate}
  \item On each of the computers, install the nfs software if not
    already installed.  For example, on Debian 9 you will need to run:
    (be sure to check/verify before using any command line):
\begin{lstlisting}[style=sh]
apt-get install nfs-kernel-server
\end{lstlisting}
  \item On the computer that contains the disk storage to be shared,
    define the network filesystem.  For example to export \texttt{/tmp},
    edit the \texttt{/etc/exports} file to add the following line:
\begin{lstlisting}[style=sh]
 192.168.1.0/24(rw,fsid=1,no_root_squash,sync,no_subtree_check)
\end{lstlisting}
  \item Next reset the exported nfs directories using:
\begin{lstlisting}[style=sh]
exportfs -ra
\end{lstlisting} and you may have to start or restart nfs:
\begin{lstlisting}[style=sh]
systemctl restart nfs
\end{lstlisting}
  \item Each of the render farm computers must mount the exported
    nfs target path.  To see the exports which are visible from a
    client, login as root to the client machine and keyin:
\begin{lstlisting}[style=sh]
showmount -e <ip-addr> #using the ip address of the storage host
\end{lstlisting}
  \item to access the host disk storage from the other computers in
    the render farm, mount the nfs export on the corresponding target
    path: (be sure to check/verify before using any command line):
\begin{lstlisting}[style=sh]
mount -t nfs <ip-addr>:/<path> <path>
\end{lstlisting} where \texttt{<path>} is the storage host
    directory, and \texttt{<ip-addr>} is the network address of the
    storage host.  Because all of the computers must have the same
    directory path, create that same directory path with the same
    uid/gid/permissions on each storage client computer ahead of time.
  \item To make this permanent across reboots on the client nodes,
    add the following line to \texttt{/etc/fstab}:
\begin{lstlisting}[style=sh]
{masternode}:/nfsshare /mnt nfs defaults 0 0
\end{lstlisting} You can make this permanent on the disk storage
    host BUT the command lines shown, which were correct in January 2018
    on Fedora, may be different for your operating system or in the
    future.  In addition if your network is not up, there may be
    numerous problems.  If you make a mistake, your system may not boot.
    To make permanent, add the following line to \texttt{/etc/fstab}:
\begin{lstlisting}[style=sh]
192.168.1.12:/tmp /tmp nfs rw,async,hard,intr,noexec,noauto 0 0
\end{lstlisting} You will still have to mount the above manually
    because of the \textit{noauto} parameter but you won’t have to
    remember all of the other necessary parameters.  Depending on your
    expertise level, you can change that.

    Later, to remove access to the storage host filesystem:
\begin{lstlisting}[style=sh]
umount <path>
\end{lstlisting}

    Be aware that you may have to adjust any security or firewalls
    you have in place.  \textit{Most firewalls will require extra rules
      to allow nfs access}.  Many have built-in configurations for this.
  \end{enumerate}
\item[Configure Rendering on Master Node] There is 1 master node
  which is running the \CGG{} gui and where the video will be edited
  and the command given to start up the rendering.  Any number of
  client computers can be run from the command line only, so they can
  be headless since no X or any graphical libraries are needed.  Of
  course, the \CGG{} software must be installed on each of the client
  computers.
  \begin{enumerate}
  \item Assuming you already have \CGG{} installed on the master
    node, start \CGG{} by clicking on the icon or by typing the
    following command on the terminal screen:
    \texttt{/{cinelerra\_path}/cin}.
  \item Use the \textit{File} pulldown \texttt{Settings $\rightarrow$
      Preferences}, the Performance tab, to set up your Render Farm
    options in the Render Farm pane.
  \item Check the \textit{Use render farm} option.  By default, once
    you enable the option of Render Farm, rendering is usually done
    using the render farm.  Batch rendering can be done locally, or
    farmed.
  \item Add the hostname or the IP address of each of the client
    nodes in the Hostname textbox and the port number that you want to
    use in the Port textbox.  You can make sure a port number is not
    already in use by keying in on the command line:
\begin{lstlisting}[style=sh]
netstat -n -l -4 --protocol inet
\end{lstlisting} Next, click on the \textit{Add Nodes} button and
    then you will see that host appear in the Nodes list box to the
    right.  The \texttt{X} in the first column of the nodes box denotes
    that the node is active.  To review the \textit{standard} port
    allocations, check the \texttt{/etc/services} file.
  \item Enter the total jobs that you would like to be used in the
    \textit{Total job} textbox.
  \item The default watchdog timer initial state is usually just
    fine but can be adjusted later if needed.
  \item Click OK on the Preferences window when done.
  \end{enumerate}
\item[Create Workflow] While working on the master computer, it is
  recommended that you keep all the resources being used on the same
  shared disk.  Load your video/audio piece and do your editing and
  preparation.  Add any desired plugins, such as a Title, to fine-tune
  your work.  You want to make sure your video is ready to be rendered
  into the final product.
\item[Start the Client Nodes] To start up the client nodes run
  \CGG{} from the command line on each of the client computers using
  the following command:
\begin{lstlisting}[style=sh]
/{cinelerra_pathname}/cin -d [port number]
# for example:
/mnt1/bin/cinelerra -d 401
\end{lstlisting} This starts \CGG{} in command prompt mode so that
  it listens to the specified port number for commands from the master
  node for rendering.  When you start each of the clients up, you will
  see some messages scroll by as each client is created on that
  computer, such as:
\begin{lstlisting}[style=sh]
RenderFarmClient::main_loop: client started
RenderFarmClient::main_loop: Session started from 127.0.0.1
\end{lstlisting} As it completes its jobs, you will should see:
\begin{lstlisting}[style=sh]
RenderFarmClientThread::run: Session finished
\end{lstlisting}
\item[Render Using Render Farm] After you have followed the
  preceding steps, you are ready to use the render farm.  Click on
  \texttt{File $\rightarrow$ Render}\dots which opens the render
  dialog.  The most important point here is to use for \textit{the
    Output path / Select a file to render to} a path/file name that is
  on the shared volume that is also mounted on the clients.  Click on
  OK to render. The \CGG{} program divides the timeline into the
  number of jobs specified by the user.  These jobs are then
  dispatched to the various nodes depending upon the load balance. The
  first segment will always render on the master node and the other
  segments will be farmed out to the render nodes.  Batch Rendering,
  as well as BD/DVD rendering, may use the render farm.  Each line in
  the batchbay can enable/disable the render farm.  Typically, video
  can be rendered into many file segments and concatenated, but
  normally audio is rendered as one monolithic file (not farmed).

  Another performance feature which can use the Render Farm is
  \textit{Background Rendering}.  This is also enabled on the
  \texttt{Preferences $\rightarrow$ Performances} tab.  The background
  render function generates a set of image files by pre-rendering the
  timeline data on the fly.  As the timeline is update by editing, the
  image data is re-rendered to a \textit{background render} storage
  path.  The Render Farm will be used for this operation if it is
  enabled at the same time as the \textit{background render} feature.
\item[Assemble the Output Files] Once all of the computer jobs are
  complete, you can put the output files together by using the shell
  script, \textit{RenderMux} (from the menubar \textit{scripts} button
  just above FF), if the files were rendered using ffmpeg (see \nameref{sec:menu_bar_shell_commands}).
  
  If you want to remain within the open project in \CGG{}, you can load these files by creating a new track and specifying concatenate to
  existing tracks in the load dialog in the correct numerical order.
  File types which support direct copy can be concatenated into a
  single file by rendering to the same file format with render farm
  disabled as long as the track dimensions, output dimensions, and
  asset dimensions are equal.
  
  Finally if you want to use ffmpeg from terminal externally to \CGG{} you can go to the directory where the rendered files are, it creates a text file \texttt{list.txt} containing the list of all our files:
  \begin{lstlisting}[style=sh]
  	file 'name.webm001'
  	file 'name.webm002'
  	...
  	file 'name.webm00n'
  \end{lstlisting}
  and finally give the command
  \begin{lstlisting}[style=sh]
  	ffmpeg -f concat -i list.txt -c copy output.webm
  \end{lstlisting}
\end{description}

\subsection{Quick and Easy Render Farm Setup – The Buddy System
  Way}%
\label{sub:buddy_system_way}

These steps are for quickly setting up render farm with the least
amount of additional system work, but it is non-optimal.  It is
useful in situations where a few people all show up with their
laptops to work together on the same video/audio file and you don’t
want to bother setting up NFS for a shared disk.

\begin{enumerate}
\item Make sure the \CGG{} program is installed on all of the
  computers and the network between the main computer and the client
  computers is working.  Use the same version if possible.
\item Load your video file on the master node and use \texttt{File
    $\rightarrow$ Save as}\dots to save it to \texttt{/tmp}.
\item Move that same file with the same name to \texttt{/tmp} on all
  of the client computers via rsh or sneaker net -- the ONLY reason
  you are doing this is to avoid having to set up NFS or Samba on the
  buddy client laptops that show up!
\item Edit your video/audio file to get it the way you want it and
  add the plugins, such as a Title, etc.
\item Check for a set of unused ports in \texttt{/etc/services}
  file, if username is root usually $401-425$ are available; if
  non-root, then $10650-10799$.
\item On the master computer, in \texttt{Settings $\rightarrow$
    Preferences, Performance} tab:
  \begin{itemize}
  \item check the box \textit{Use render farm}
  \item keyin localhost for the hostname or an ip address of the
    buddy client node
  \item keyin the desired port number for each client; and use
    \textit{Add Node} for each host
  \item set total jobs to the number of client computers $+1$
    multiplied by $3$ (or proportion to client speeds)
  \item check OK
  \end{itemize}
\item On each buddy client, create a job for each port:
\begin{lstlisting}[style=sh]
/{cinelerra_pathname}/cin -d port#
\end{lstlisting}
\item On the master, bring up the render menu and name the output
  files, for example \texttt{/tmp/myoutput.webm}.
\item The client nodes output results will be on their local
  \texttt{/tmp} filesystems so you will have to again use
  \textit{rsh/ftp} or \textit{usb sneaker net} to move them over to
  the main computer.  File names will be the render job output file
  name with port number tacked on
  (e.g. \texttt{/tmp/hb.webm001...webm005}).
\item Load the files by concatenate to existing track on the master
  node or use RenderMux shell script.
\end{enumerate}


\subsection{Troubleshooting Tips and Warnings}%
\label{sub:troubleshhoting_tips_warnings}
\index{render farm!troubleshooting}

\noindent If you have problems running the Render Farm.  Here is a
list of items to check.

\begin{itemize}
\item \CGG{} must be installed on the master node and all client
  machines.
\item It is best to have the same username available on all nodes to
  avoid problems with access rights.
\item Check file permissions and ownership to ensure that the
  clients all have access.
\item If a node does not have access to an input asset it will not
  die, but just display error messages.
\item If a node can not access an output asset, the rendering will
  abort.
\item A port in use when stopped may take up to $30$ seconds to time
  out before you can restart the jobs.
\item Each of the port combinations have to be unique across
  clients, and not already in use in the network.
\item \CGG{} load balances on a first come, first serve basis.  If
  the last section of the video is sent to the slowest node, the
  render job will have to wait for the slowest node to finish.  It
  would be better to start on the slowest node with the earlier
  section of the video so keep that in mind when designating port
  numbers.
\item If not running as root, a port number in the higher range of
  $10650$ and above must be used instead of the $401+$ range.
\item The master and client jobs on the ports do not go away so if
  you want to stop them, you will have to kill them via: \texttt{kill
    PID\#}.
\item Check to see if there are services listening on the ports to
  use: \texttt{netstat -n -l -4 --protocol inet}
\item There is a watchdog timer in \CGG{} and if there is no
  response from a client in the designated number of seconds, it will
  kill the render job.
\item The \textit{localhost} should exist as $127.0.0.1$ in
  \texttt{/etc/hosts} and as the \texttt{lo} network device in
  ifconfig.
\item If the job loads become unbalanced, you may want to
  \textit{reset rates} to start over for new framerates.
\item If jobs are split in a key section on the timeline, you may
  wish to \textit{use labels} to prevent this.
\item Adjust the \textit{Total jobs to create} for different videos that
  are considerably different in size.  You should not create so 
  many jobs that each one is very small.
\item For testing purposes, you may want to start a client in the
  foreground using \texttt{-f} instead of \texttt{-d}.
\item If one of the client computers is unavailable, check to see if
  there is an \texttt{X} to the left of the \texttt{nodename} in the
  Nodes listbox.  Check the \texttt{X} to disable it which sets ON to
  OFF.
\item A red message in the lower left hand corner of the main
  timeline that reads \textit{Failed to start render farm} often means
  that the client \CGG{} programs were not started up.
\item A message of \texttt{RenderFarmWatchdog::run 1 killing server
    thread \\ \#address\#} means that the client did not respond in
  time.  You can adjust the timer in \texttt{Settings $\rightarrow$
    Preferences, Performance} tab.
\item When you get the message \texttt{RenderFarmClient::main\_loop:
    bind port 400: Address already in use}, use a different port. See \texttt{/etc/services} for free ports.
\item A message of \texttt{RenderFarmServerThread::open\_client:
    unknown host abcompany} means that the hostname of abcompany is not
  in \texttt{/etc/hosts} so you will have to add it or use the ip
  address instead.
\item There are numerous error messages associated with file
  \textit{open/close/status} or problems with the file that should be
  dealt with according to what is printed out.
\item Other illustrative messages may be shown such as:
  \texttt{RenderFarmClientThread:: run: Session finished}.
\end{itemize}

And here are a couple of more tips for making Render Farm specific
for your setup.
\begin{itemize}
\item Because \textit{index files} speed up displaying the video you
  may want to share these files with the clients on a shared
  filesystem. More information on index files configuration is
  outlined in~\ref{sub:index_file_section}.
\item Or, one of the convenient features of \CGG{} is the
  redirection of the path via \texttt{CIN\_CONFIG} as in:
\begin{lstlisting}[style=sh]
CIN_CONFIG="/<shared_file_pathname>/<filename_such_as_.bcast5>" cin
\end{lstlisting} This means that you can make project related
  configurations that do not impact the default \texttt{\$HOME}
  config.  You can either export your default \texttt{\$HOME} config
  or the \texttt{CIN\_CONFIG} config to use on the render farm.
\end{itemize}

\paragraph{Warnings}

If one of the render farm computers is connected to the internet,
you should use a firewall to maintain the safety of all of the
computers.  The ports have to be reachable for the intranet but you
do not want the ports to be open to the outside.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../CinelerraGG_Manual"
%%% End:
